
# allow class name being used before being fully defined (like in same class):
from __future__ import annotations

from kiss_cf.storage import StorageMaster
from kiss_cf.config import Config
from kiss_cf.security import Security

from ._registration_request import RegistrationRequest
from ._registration_response import RegistrationResponse
from ._user_id import UserId
from ._user_db import UserDatabase


class KissRegistryUnitialized(Exception):
    ''' Trying to use an uninitialized registry '''


class KissRegistryUnknownConfigSection(Exception):
    ''' Trying to use an uninitialized registry '''


class Registry:
    ''' User registry maintains the application user's ID and all user
        configurations the user is permitted to see. '''

    def __init__(self,
                 storage: StorageMaster,
                 security: Security,
                 config: Config,
                 **kwargs):
        super().__init__(**kwargs)
        self._loaded = False
        self._security = security
        self._config = config

        self._user_db = UserDatabase(storage.get_storage('USER_DB'))
        self._user_id = UserId(storage.get_storage('USER_ID'))

    def get_roles(self, id: int | None = None) -> list[str]:
        if id is None:
            self._ensure_loaded()
            id = self._user_id.id
        return self._user_db.get_roles(id)

    def is_initialized(self) -> bool:
        return (self._loaded or (
                self._user_id._storage.exists() and
                self._user_db._storage.exists()
                ))

    def _ensure_loaded(self):
        if self._loaded:
            return None
        if not self.try_load():
            KissRegistryUnitialized('Registry is not initialized.')

    def try_load(self) -> bool:
        if not self.is_initialized():
            return False
        self._user_id.load()
        self._user_db.load()
        self._loaded = True
        return True

    def initialize_as_admin(self):
        ''' Initialize databse

        This function is expected to be called only once in the entire tool
        life cycle by user 0. New admins will inherit the existing data.
        '''
        self._user_id.id = self._user_db.init_user_db(
            validation_key=self._security.get_signing_public_key(),
            encryption_key=self._security.get_encryption_public_key())
        self._loaded = True

    def get_request_bytes(self) -> bytes:
        ''' Get registration request bytes

        Bytes are sent to an admin outside of this tools scope. For example, as
        a file via Email.
        '''
        # TODO: add encryption which will require the AMDIN_DB

        # TODO: add warning message the _loaded is True
        return RegistrationRequest.new(
            self._config.section('USER').data,
            self._security).get_request_bytes()

    def get_request_data(self, request: bytes) -> RegistrationRequest:
        return RegistrationRequest.from_request(request)

    def add_user_from_request(self,
                              request: RegistrationRequest,
                              roles: list[str] = ['user']) -> int:
        ''' Store user in databse and get user ID

        The admin is expected to use this function. The request bytes are
        generated by get_request_bytes() on user side. After user is added, the
        admin uses get_response_bytes() to send data back to user.
        '''
        if not self._loaded:
            raise KissRegistryUnitialized(
                'registry is not yet loaded, cannot add user')
        return self._user_db.add_new(
            validation_key=request.signing_key,
            encryption_key=request.encryption_key,
            roles=roles)

    def get_response_bytes(self,
                           user_id: int,
                           sections: list[str] = []) -> bytes:
        ''' Get response bytes from admin to user

        Bytes are sent back to user outside of tis tool's scope. For example,
        as file via Email. See: get_request_bytes().
        '''
        if not self._loaded:
            raise KissRegistryUnitialized(
                'registry is not yet loaded, cannot construct a response')
        # check sections existing before applying
        for section in sections:
            if section not in self._config.sections:
                raise KissRegistryUnknownConfigSection(
                    f'Section {section} does not exist.')
        response = RegistrationResponse.new(
            user_id,
            {section: self._config.section(section).data
             for section in sections})
        return response.get_response_bytes()

    def set_response_bytes(self, response_bytes: bytes):
        ''' Set registration response '''

        # TODO: add warning if already loaded

        response = RegistrationResponse.from_response_bytes(response_bytes)

        for section in response.config_sections:
            self._config.section(section).update(
                response.config_sections[section])
            self._config.section(section).store()

        # only store user_id after retrieving all configuration to keep
        # application "uninitialized" until then
        self._user_id.id = response.user_id
        self._user_id.store()

        # TODO: check incoming information and log (1) the retrieved ID and (2)
        # and incoming config sections that are updated and (3) the admin that
        # did this (public singing key).

        # TODO: verify the response matching the keys.

        # TODO: update user config (admin might have done adaptions)

        # TODO: update configuration with incoming information
        # TODO: sync (or restart?)

        # TODO: clarfify how it is checked that everything worked

    def get_encryption_keys(self, roles: list[str] | str) -> list[bytes]:
        return self._user_db.get_encryption_keys(roles)

# TODO: can we register the same user twice? How would we know? We
# would need to double-check the keys (which we did not want to use as
# ID's). We could maintain some "ongoing registrations" data. Note that
# there is currently no tool supported feedback on a registration
# success (when the user has applied the registration response).

# TODO: add user information to some DB? Users may distribute to admins and
# admins re-distribute to users.
#
# We do not want to write different USER_DB versions for each user.
# Likewise, we do not want to write an information file for each user that
# is encrypted for lot's of users. However, we want to use the default
# shared file sync mechanism. This leaves:
#   * Write bulks of user data information per role.
# Consequences:
#   * One file per ROLE (not per USER)
#   * User information may be contained in multiple ROLE files.
# If user information size is SIZE_UI and size of encryption data is SIZE_KEY,
# the total size is:
#   * For one file, each user:
#       USERS * (SIZE_UI + AVG_USER_IN_ROLE * SIZE_KEY)
#   * For one file, each group:
#       ROLES * (AVG_USER_IN_ROLE * SIZE_UI + AVG_USER_IN_ROLE * SIZE_KEY)
#   * Assuming AVG_USER_IN_ROLE ~ USERS/ROLES
#       * First: USERS * SIZE_UI + USERS^2/ROLES * SIZE_KEY
#           USERS * SIZE_UI >> guaranteed
#           USERS^2/ROLES * SIZE_KEY >> certainly a problem
#       * Second: USERS * SIZE_UI + USERS * SIZE_KEY
#           USERS * SIZE_UI >> not correct admin will know all, depot
#             responsibles will be known by most roles. Worst case:
#             each role knows all users: USERS * ROLES * SIZE_UI.
#           USERS * SIZE_KEY >> also not correct since users may know
#             multiple roles input. Worst case here is, again:
#             USERS * ROLES * SIZE_UI
#       * Second corrected but worst case:
#             ROLES * USERS * (SIZE_UI + SIZE_KEY)
#
# Number examples, assuming email (16 bytes) plus name (20 bytes) rounded
# up to 50 bytes for SIZE_UI. And an encrpted key blob with 256 bytes.
#   * 10 USERS shared with all users (worst case): 10*50 + 10*10*256 = 26k
#   * 10 USERS shared with 5 ROLES: 10*5*50 + 10*5*256 = 15k
#
#   * 20 USERS shared with all users (worst case): 103k
#   * 20 USERS shared with 5 roles: 31k
